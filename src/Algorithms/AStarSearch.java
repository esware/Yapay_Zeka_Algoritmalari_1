package Algorithms;import java.util.*;import Simulations.*;public class AStarSearch implements Algorithm{    public String nodeList;    public int totalNodeCount;    public List<int[]> goalList = new ArrayList<>();    private Environment environment;    private Set<String> simulatedEatenCookies = new HashSet<>();    private static final int[] dx = {-1, 1, 0, 0};    private static final int[] dy = {0, 0, 1, -1};    public AStarSearch(Environment e)    {        environment=e;        goalList = getGoals();    }    @Override    public String getName() {        return "AStar Search";    }    public int[] findOptimalPath()    {        PriorityQueue<SearchNode> openList = new PriorityQueue<>(Comparator.comparingInt(n -> n.f));        Map<String, SearchNode> allNodes = new HashMap<>();        int[] start = environment.getStart();        SearchNode startNode = new SearchNode(start[0],start[1], 0, 0, -1,null);        openList.add(startNode);        allNodes.put(Arrays.toString(environment.getStart()), startNode);        while (!openList.isEmpty())        {            SearchNode current = openList.poll();            if (simulatePathAndCheckGoal(current)) {                return constructPath(current);            }            simulatedEatenCookies.clear();            for (int action = 0; action < 4; action++) {                int newX = current.x + dx[action];                int newY = current.y + dy[action];                if (!environment.isValidLocation(newX, newY) || environment.hasObstacle(newX, newY))                    continue;                String nextStateKey = newX + "," + newY;                int tentativeG = current.g + 1;                if ((!allNodes.containsKey(nextStateKey) || tentativeG < allNodes.get(nextStateKey).g) ) {                    int tentativeF = tentativeG + estimateHeuristic(new int[]{newX, newY});                    SearchNode nextNode = allNodes.getOrDefault(nextStateKey, new SearchNode(newX, newY, tentativeG, tentativeF, action, current));                    allNodes.put(nextStateKey, nextNode);                    if (!openList.contains(nextNode)) {                        openList.add(nextNode);                    }                }            }            System.out.println("Açık Liste:");            for (SearchNode node : openList)            {                String nodeString = String.format("Node [x=%d, y=%d, g=%d, f=%d]\n", node.x, node.y, node.g, node.f);                nodeList += nodeString;                totalNodeCount+=1;            }        }        return null; // Yol bulunamadı.    }    private boolean simulatePathAndCheckGoal(SearchNode node)    {        int[] state = environment.getStart();        int[] path = constructPath(node);        for (int action : path) {            state = simulateRobotAction(state, action);        }        return isGoal();    }    private int[] simulateRobotAction(int[] state, int action)    {        int x = state[0];        int y = state[1];        switch (action)        {            case 0: --x; break;            case 1: ++x; break;            case 2: ++y; break;            case 3: --y; break;        }        if (environment.hasObstacle(x,y)){            return new int []{state[0],state[1]};        }        if (environment.hasCookie(x, y))        {            simulatedEatenCookies.add(x + "," + y);        }        return new int[]{x, y};    }    private List<int[]> getGoals()    {        List<int[]> goals = new ArrayList<>();        for(int i = 0; i < environment.getHeight(); ++i) {            for(int j = 0; j < environment.getWidth(); ++j) {                if (environment.getEnvironment()[i][j] == 2) {                    goals.add(new int[]{i,j});                }            }        }        return goals;    }    public boolean isGoal()    {        for(int i = 0; i < environment.getHeight(); i++)        {            for(int j = 0; j < environment.getWidth(); j++)            {                if (environment.hasCookie(i,j) && !simulatedEatenCookies.contains(i + "," + j))                {                    return false;                }            }        }        return true;    }    public int estimateHeuristic(int[] state) {        int minDistance = Integer.MAX_VALUE;        for (int[] goal : goalList) {            if (!simulatedEatenCookies.contains(goal[0] + "," + goal[1])) {                int distance = calculateManhattanDistance(state, goal);                minDistance = Math.min(minDistance, distance);            }        }        return minDistance == Integer.MAX_VALUE ? 0 : minDistance;    }    private int calculateManhattanDistance(int[] start, int[] end) {        // Basit Manhattan mesafesi        int distance = Math.abs(start[0] - end[0]) + Math.abs(start[1] - end[1]);        // Engelleri dikkate almak için daha gelişmiş bir tahmin        int obstacleCount = countObstaclesOnPath(start, end);       // distance += obstacleCount; // Her engel için bir maliyet ekle        return distance;    }    private int countObstaclesOnPath(int[] start, int[] end) {        int obstacleCount = 0;        // Yolu takip ederek engelleri say        // Bu fonksiyon daha karmaşık bir yolu temsil edebilir        // Örneğin, ray casting veya Bresenham's line algorithm gibi bir yöntem kullanabilirsiniz        // Örnek olarak, basit bir doğrusal yol kontrolü yapalım        int dx = Integer.compare(end[0], start[0]);        int dy = Integer.compare(end[1], start[1]);        int x = start[0];        int y = start[1];        while (x != end[0] || y != end[1]) {            if (environment.hasObstacle(x, y)) {                obstacleCount++;            }            if (x != end[0]) x += dx;            if (y != end[1]) y += dy;        }        return obstacleCount;    }    private int[] constructPath(SearchNode node) {        ArrayList<Integer> path = new ArrayList<>();        while (node != null) {            path.add(node.action);            node = node.parent;        }        Collections.reverse(path);        int[] pathArray = new int[path.size()];        for (int i = 0; i < path.size(); i++) {            pathArray[i] = path.get(i);        }        System.out.println("Bulunan Path: ");        for (int action : pathArray) {            System.out.print(action + " ");        }        System.out.println();        return pathArray;    }    public static class SearchNode    {        public int x, y, g,f, action;        SearchNode parent;        SearchNode(int x, int y, int g,int totalCost, int action, SearchNode parent)        {            this.x = x;            this.y = y;            this.g = g;            this.f = totalCost;            this.action = action;            this.parent = parent;        }        public int getX(){return x;}    }}