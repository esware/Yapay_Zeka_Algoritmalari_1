package Algorithms;import java.util.*;import Simulations.*;public class GeneticAlgorithm implements Algorithm{    private Set<String> simulatedEatenCookies = new HashSet<>();    private int populationSize;    private double mutationRate;    private Random random;    private int chromosomeLength;    private int maxGenerations;    private int totalChromosomesGenerated = 0;    private Environment environment;    public int getPopulationSize() {        return populationSize;    }    public double getMutationRate() {        return mutationRate;    }    public int getChromosomeLength() {        return chromosomeLength;    }    public int getMaxGenerations() {        return maxGenerations;    }    public Environment getEnvironment() {        return environment;    }    public GeneticAlgorithm(Environment e , int populationSize, double mutationRate, int chromosomeLength, int maxGenerations)    {        environment=e;        this.populationSize = populationSize;        this.mutationRate = mutationRate;        this.chromosomeLength = chromosomeLength;        this.maxGenerations = maxGenerations;        this.random = new Random();    }    @Override    public String getName() {        return "Genetic Algorithm";    }    public int[] findOptimalPath()    {        // İlk popülasyonu oluştur        List<List<Integer>> population = initializePopulation(populationSize, chromosomeLength);        for (int generation = 0; generation < maxGenerations; generation++)        {            // Uygunluk değerlerini hesapla            List<Double> fitnessValues = calculateFitness(population);            // En yüksek fitness değerine sahip kromozomu bul            int bestIndex = fitnessValues.indexOf(Collections.max(fitnessValues));            List<Integer> bestChromosome = population.get(bestIndex);            int[] bestPath = new int[bestChromosome.size()];            int[] state = environment.getStart();            for (int i = 0; i < bestChromosome.size(); i++)            {                bestPath[i] = bestChromosome.get(i);                state = simulateRobotAction(state,bestPath[i]);            }            // Hedefe ulaşıldıysa, en iyi yolu döndür            if (isGoal())            {                return bestPath;            }            simulatedEatenCookies.clear();            // Seçim, çaprazlama ve mutasyon işlemleri            List<List<Integer>> selected = select(population, fitnessValues);            List<List<Integer>> crossoverPopulation = crossover(selected);            mutate(crossoverPopulation);            population = crossoverPopulation;        }        return null; // Hedefe ulaşılamadı.    }    private List<List<Integer>> initializePopulation(int size, int chromosomeLength) {        List<List<Integer>> population = new ArrayList<>();        for (int i = 0; i < size; i++) {            List<Integer> chromosome = new ArrayList<>();            for (int j = 0; j < chromosomeLength; j++) {                chromosome.add(random.nextInt(4)); // 0-3 arası rastgele hareketler (Kuzey, Güney, Doğu, Batı)            }            population.add(chromosome);            totalChromosomesGenerated++; // Her kromozom oluşturulduğunda sayacı artır        }        return population;    }    private List<Double> calculateFitness(List<List<Integer>> population) {        List<Double> fitnessValues = new ArrayList<>();        for (List<Integer> chromosome : population) {            double fitness = evaluateChromosome(chromosome);            fitnessValues.add(fitness);        }        return fitnessValues;    }    private double evaluateChromosome(List<Integer> chromosome)    {        int collectedCookies = 0;        boolean hitObstacle = false;        int[] state = environment.getStart();        int x = state[0];        int y = state[1];        for (int action : chromosome)        {            state = simulateRobotAction(state,action);            if (environment.hasObstacle(x,y))            {                x = state[0];                y = state[1]; // pozisyonlar guncellenmedi.                hitObstacle=true;                continue;            }            if (environment.hasCookie(x, y))            {                collectedCookies++;            }        }        // Uygunluk puanını hesapla        double fitness = collectedCookies;        if (hitObstacle)        {            fitness /= 1.4f; // Eğer engelle karşılaşıldıysa puanı düşür        }        simulatedEatenCookies.clear();        return fitness;    }    private int[] simulateRobotAction(int[] state, int action)    {        int x = state[0];        int y = state[1];        switch (action) {            case 0: --x; break;            case 1: ++x; break;            case 2: ++y; break;            case 3: --y; break;        }        if (environment.hasObstacle(x,y))        {            return new int[]{state[0],state[1]};        }        if (environment.hasCookie(x, y))        {            simulatedEatenCookies.add(x + "," + y);        }        return new int[]{x, y};    }    private List<List<Integer>> select(List<List<Integer>> population, List<Double> fitnessValues) {        double totalFitness = fitnessValues.stream().mapToDouble(f -> f).sum();        List<Double> cumulativeFitness = new ArrayList<>();        double cumulative = 0.0;        for (Double fitness : fitnessValues) {            cumulative += fitness;            cumulativeFitness.add(cumulative);        }        List<List<Integer>> selected = new ArrayList<>();        for (int i = 0; i < populationSize; i++) {            double randomFitness = random.nextDouble() * totalFitness;            int selectedIndex = 0;            while (selectedIndex < cumulativeFitness.size() - 1 &&                    cumulativeFitness.get(selectedIndex) < randomFitness) {                selectedIndex++;            }            selected.add(population.get(selectedIndex));        }        return selected;    }    private List<List<Integer>> crossover(List<List<Integer>> population) {        List<List<Integer>> newPopulation = new ArrayList<>();        for (int i = 0; i < population.size() / 2; i++) {            int parent1Index = random.nextInt(population.size());            int parent2Index = random.nextInt(population.size());            List<Integer> parent1 = population.get(parent1Index);            List<Integer> parent2 = population.get(parent2Index);            // Rastgele çaprazlama noktası belirle            int crossoverPoint = random.nextInt(chromosomeLength);            // Çaprazlama için iki yeni birey oluştur            List<Integer> child1 = new ArrayList<>();            List<Integer> child2 = new ArrayList<>();            // Çaprazlama noktasına kadar olan genleri ilk ebeveynden al            for (int j = 0; j < crossoverPoint; j++) {                child1.add(parent1.get(j));                child2.add(parent2.get(j));            }            // Çaprazlama noktasından sonra olan genleri diğer ebeveynden al            for (int j = crossoverPoint; j < chromosomeLength; j++) {                child1.add(parent2.get(j));                child2.add(parent1.get(j));            }            newPopulation.add(child1);            newPopulation.add(child2);        }        totalChromosomesGenerated += newPopulation.size(); // Çaprazlama sonucu oluşan yeni kromozomları sayaca ekle        return newPopulation;    }    private void mutate(List<List<Integer>> population) {        // Her birey üzerinde mutasyon işlemi gerçekleştir        for (List<Integer> chromosome : population) {            if (random.nextDouble() < mutationRate) {                int mutationPoint = random.nextInt(chromosome.size());                chromosome.set(mutationPoint, random.nextInt(4)); // Rastgele bir hareket ile değiştir            }        }    }    public boolean isGoal() {        for(int i = 0; i < environment.getHeight(); i++) {            for(int j = 0; j < environment.getWidth(); j++) {                if (environment.hasCookie(i,j) && !simulatedEatenCookies.contains(i + "," + j)) {                    return false;                }            }        }        return true;    }    public int getTotalChromosomesGenerated() {        return totalChromosomesGenerated;    }}