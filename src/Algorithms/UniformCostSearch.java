package Algorithms;import java.util.*;import Simulations.*;public class UniformCostSearch implements Algorithm{    public int totalNodeCount;    private PriorityQueue<SearchNode> frontier = new PriorityQueue<>(Comparator.comparingInt(n -> n.cost));    private Set<String> explored = new HashSet<>();    private Set<String> simulatedEatenCookies = new HashSet<>();    private static final int[] dx = {-1, 1, 0, 0};    private static final int[] dy = {0, 0, 1, -1};    private Environment environment;    public UniformCostSearch(Environment e){        environment=e;    }    @Override    public String getName() {        return "UniformCostSearch";    }    public int[] findOptimalPath() {        int[] start = environment.getStart();        frontier.add(new SearchNode(start[0], start[1], 0, 1, null));        while (!frontier.isEmpty())        {            SearchNode current = frontier.poll();            if (simulatePathAndCheckGoal(current)) {                return constructPath(current);            }            simulatedEatenCookies.clear();            explored.add(current.x + "," + current.y);            for (int i = 3; i >=0; --i) {                int newX = current.x + dx[i];                int newY = current.y + dy[i];                if (!explored.contains(newX + "," + newY) && environment.isValidLocation(newX, newY) && !environment.hasObstacle(newX,newY))                {                    frontier.add(new SearchNode(newX, newY, current.cost + 1, i, current));                    totalNodeCount+=1;                }            }        }        return null; // Yol bulunamadÄ±    }    private boolean simulatePathAndCheckGoal(SearchNode node)    {        int[] state = environment.getStart();        int[] path = constructPath(node);        for (int action : path) {            state = simulateRobotAction(state, action);        }        return isGoal();    }    private int[] simulateRobotAction(int[] state, int action) {        int x = state[0];        int y = state[1];        switch (action) {            case 0: --x; break;            case 1: ++x; break;            case 2: ++y; break;            case 3: --y; break;        }        if (environment.hasObstacle(x,y)){            return new int[]{state[0],state[1]};        }        if (environment.hasCookie(x, y))        {            simulatedEatenCookies.add(x + "," + y);        }        return new int[]{x, y};    }    public boolean isGoal() {        for(int i = 0; i < environment.getHeight(); i++) {            for(int j = 0; j < environment.getWidth(); j++) {                if (environment.hasCookie(i,j) && !simulatedEatenCookies.contains(i + "," + j)) {                    return false;                }            }        }        return true;    }    private int[] constructPath(SearchNode node) {        ArrayList<Integer> path = new ArrayList<>();        while (node != null) {            path.add(node.action);            node = node.parent;        }        Collections.reverse(path);        int[] pathArray = new int[path.size()];        for (int i = 0; i < path.size(); i++) {            pathArray[i] = path.get(i);        }        System.out.println("Bulunan Path: ");        for (int action : pathArray) {            System.out.print(action + " ");        }        System.out.println();        return pathArray;    }}